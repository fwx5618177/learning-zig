# 栈内存

通过深入研究指针，我们了解了变量、数据和内存之间的关系。因此，我们对内存的分布有了一定的了解，但我们还没有讨论如何管理数据以及内存。对于短期和简单的脚本来说，这可能并不重要。在 32GB 笔记本电脑时代，你可以启动程序，使用几百兆内存读取文件和解析 HTTP 响应，做一些了不起的事情，然后退出。程序退出时，操作系统会知道，它给程序提供的内存可以被回收，并用于其他用途了。```

可如果此程序运行的时间以天、月甚至年来计数，此机器上的其他运行中的进程可能也在争夺相同的内存，那内存就会变成一种有限且珍贵的资源。简单等待程序退出并释放内存的策略并不可行，而垃圾回收器的主要工作是知道哪些数据不再使用并释放内存。在 Zig 中，你就是垃圾回收器。

你编写的大部分程序将使用三块内存的“区域”。第一块是全局空间。它主要储存程序常量，包括字符串字面量。所有的全局数据都被编译到二进制中，在编译期间以及运行时完全已知且不可变。这些数据将会在整个程序的生命周期中存在，永不需要增加或减少内存。除了会影响二进制文件的大小，但我们不需要关心这个问题。

内存的第二块区域是调用栈，是我们本章内容。而第三块区域是堆，将在下一章讨论。

> 三块内存区域实际上没有真正的物理差别。操作系统和可执行文件创造了“内存区域”这个概念。

## 栈帧

迄今为止，我们所见的所有数据都是常量，存储在二进制的全局数据部分或作为局部变量。“局部”表示该变量只在其声明的范围内有效。在 Zig 中，范围从花括号开始到结束，`{ ... }`。大多数变量的范围限定在一个函数内，包括函数参数，或一个控制流块，比如 if。但是，正如所见，你可以创建任意块，从而创建任意范围。

在上一部分中，我们可视化了 main 和 levelUp 函数的内存，每个函数都有一个 User:

```bash
main: user ->    -------------  (id: 1043368d0)
                 |     1     |
                 -------------  (power: 1043368d8)
                 |    100    |
                 -------------  (name.len: 1043368dc)
                 |     4     |
                 -------------  (name.ptr: 1043368e4)
                 | 1182145c0 |-------------------------
levelUp: user -> -------------  (id: 1043368ec)       |
                 |     1     |                        |
                 -------------  (power: 1043368f4)    |
                 |    100    |                        |
                 -------------  (name.len: 1043368f8) |
                 |     4     |                        |
                 -------------  (name.ptr: 104336900) |
                 | 1182145c0 |-------------------------
                 -------------                        |
                                                      |
                 .............  空                    |
                 .............  其他数据               |
                                                      |
                 -------------  (1182145c0)        <---
                 |    'G'    |
                 -------------
                 |    'o'    |
                 -------------
                 |    'k'    |
                 -------------
                 |    'u'    |
                 -------------
```

levelUp 紧接在 main 之后是有原因的：这是我们的[简化版]调用栈。当我们的程序启动时，main 及其局部变量被推入调用栈。当 levelUp 被调用时，它的参数和任何局部变量都会被推送到调用栈上。重要的是，当 levelUp 返回时，它会从栈中弹出。 在 levelUp 返回并且控制权回到 main 后，我们的调用栈如下所示：

```bash
main: user ->    -------------  (id: 1043368d0)
                 |     1     |
                 -------------  (power: 1043368d8)
                 |    100    |
                 -------------  (name.len: 1043368dc)
                 |     4     |
                 -------------  (name.ptr: 1043368e4)
                 | 1182145c0 |-------------------------
                 -------------
                                                      |
                 .............  空                    |
                 .............  其他数据               |
                                                      |
                 -------------  (1182145c0)        <---
                 |    'G'    |
                 -------------
                 |    'o'    |
                 -------------
                 |    'k'    |
                 -------------
                 |    'u'    |
                 -------------
```

当一个函数被调用时，其整个栈帧被推入调用栈——这就是我们需要知道每种类型大小的原因之一。尽管我们可能直到特定的代码行执行时，才能知道我们 user 的名字的长度（假设它不是一个常量字符串字面量），但我们知道我们的函数有一个 User，除了其他字段，我们需要 8 字节来存储`name.len`和 8 字节来存储`name.ptr`。

当函数返回时，最后被推入调用栈的栈帧会被弹出。这时，一件惊人的事情发生了：levelUp 使用的内存已经自动释放！虽然从技术上讲，该内存可以归还给操作系统，但据我所知，没有操作系统或编程语言运行时环境实际上会缩小调用栈的大小（在必要时，这些系统或环境会动态地增长它）。然而，用来存储 levelUp 的栈帧的内存现在可以被我们的进程用于另一个栈帧。

> 在正常的程序中，调用栈可能会变得相当大。在典型程序使用的所有框架代码和库之间，最终会得到深度嵌套的函数。通常这不是问题，但偶尔，你可能会遇到某种类型的栈溢出错误。这种情况发生是因为我们的调用栈用尽了空间。这种情况更多的是发生在递归函数中——这个函数调用自身。

和我们的全局数据一样，调用栈由操作系统和可执行文件管理。在程序启动时，以及我们之后启动的每个线程，都会创建一个调用栈（其大小通常可以在操作系统中配置）。调用栈存在于程序的生命周期中，或者在一个线程的情况下，存在于线程的生命周期中。在程序或线程退出时，调用栈被释放。但与我们的全局数据拥有所有程序的全局数据不同，调用栈只有当前执行的函数层次结构的栈帧。这在内存使用以及推入和弹出栈帧的简单性方面都是高效的。

## 悬空指针

调用栈因其简单性和效率而令人赞叹。但它也令人恐惧：当一个函数返回时，其内部的任何局部数据都会无法访问。因为是局部数据所以情有可原，但它可能引入严重的问题。考虑以下代码：

```zig
const std = @import("std");

pub fn main() void {
	var user1 = User.init(1, 10);
	var user2 = User.init(2, 20);

	std.debug.print("User {d} has power of {d}\n", .{user1.id, user1.power});
	std.debug.print("User {d} has power of {d}\n", .{user2.id, user2.power});
}

pub const User = struct {
	id: u64,
	power: i32,

	fn init(id: u64, power: i32) *User{
		var user = User{
			.id = id,
			.power = power,
		};
		return &user;
	}
};
```

粗瞥一眼，预期应该如下:

```bash
User 1 has power of 10
User 2 has power of 20
```

实际上:

```bash
User 2 has power of 20
User 9114745905793990681 has power of 0
```

你可能会得到不同的结果，但根据我的输出，`user1`继承了`user2`的值，而`user2`的值是无意义的。这段代码的关键问题是`User.init`返回局部`user`的地址`&user`。这被称为悬空指针，是指引用无效内存的指针。它是许多段错误的源头。

当一个栈帧从调用栈中弹出时，我们对该内存的任何引用都是无效的。尝试访问该内存的结果是未定义的。你可能会得到无意义的数据或段错误。我们可以试图理解我的输出，但这不是我们想要或甚至可以依赖的行为。

这种类型的错误的一个挑战是，在具有垃圾收集器的语言中，上面的代码是完全没问题的。例如，Go 会检测到局部`user`超出了其作用域，`init`函数，并确保其在需要的时间内保持有效（Go 如何做到这点是一个实现的细节，但它有一些选项，包括将数据移动到堆，这是下一部分的内容）。

而另一个问题，很遗憾地说，它是一个难以发现的错误。在我们上面的例子中，我们显然返回了一个局部地址。但这种行为可以隐藏在嵌套函数和复杂数据类型中。你是否看到了以下不完整代码的任何可能问题：

```zig
fn read() !void {
	const input = try readUserInput();
	return Parser.parse(input);
}
```

无论`Parser.parse`返回什么，它都将比变量`input`存在更久。如果`Parser`持有对 `input` 的引用，那将是一个悬空指针，只等着让我们的应用崩溃。理想情况下，如果 `Parser` 需要 `input` 与其一样长久地存在，它将复制`input`，并且该复制将与它自己的生命周期绑定（更多内容在下一部分）。但此处没有执行这一步骤。`Parser` 的文档可能会对它对 `input` 的期望或它如何使用 `input` 提供一些说明。缺少这些信息，我们可能需要深入代码来弄清楚。

---

为了解决我们上面例子里的错误，有个简单的方法是改变 `init`，使它返回一个 `User` 而不是`*User`（指向 `User` 的指针）。我们可以使用 `return user;` 而非 `return &user;`。但这种方法并非一直生效。数据经常需要超越函数范围的严格边界而存在，意即存储指向`User`的指针`&user`。为此我们需要第三个内存区域: 堆。这将会是下一部分的主题。

在深入堆之前，请注意，在本指南结束之前我们将看到悬空指针的一个最终示例。而到那时，我们的讲解已经涵盖了 Zig 的大多数内容，因而会给出个稍微简单的例子。

我想重新修订这章内容，因为对那些使用自带垃圾回收器的语言的开发者来说，本章内容可能会导致一些错误和挫败感。这是掌握的过程。归根结底，需要了解数据何时何地存在。
